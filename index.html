<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
  <head> 
    <meta http-equiv="content-type" content="text/html; charset=utf-8" /> 
    <meta name="description" content="Python framework for asynchronous, concurrent programming." /> 
    <meta name="keywords" content="Python, cluster computing" /> 
    <title> 
      asyncoro - Framework for Asynchronous, Concurrent Programming
    </title> 

<link rel="stylesheet" type="text/css" href="style.css" />
 
  </head> 
  <body> 
    <center><h4>asyncoro : Framework for Asynchronous, Concurrent,
    Distributed Programming</h4></center>
    <div id="content-mask">
      <div id="content-container"> 
	<div id="content-menu">
	  <ul>
            <li><a href="discoro.html">API for Distributed Coroutines</a></li> 
            <li><a href="examples.html">Examples</a></li> 
	  </ul>
	  <hr />
	  <ul>
            <li><a href="http://sourceforge.net/projects/asyncoro/files">Download asyncoro</a></li> 
            <li><a href="http://sourceforge.net/projects/asyncoro/">Project details</a></li> 
            <li><a href="http://sourceforge.net/projects/asyncoro/support">Get support</a></li>
	  </ul>
	</div> 

	<div id="content-wrap"> 
	  <div id="content"> 

<center><h2>asyncoro</h2></center>
<p>
  asyncoro is a Python framework for developing concurrent,
  distributed programs with asynchronous completions and
  coroutines. Asynchronous completions currently implemented in
  asyncoro are socket I/O operations (for non-blocking sockets),
  database cursors, sleep timers and locking primitives.  The
  coroutines should use <em>yield</em> with these completions. Each
  yield statement gives control to asyncoro's scheduler, which
  interleaves executions of coroutines, similar to the way an
  operating system executes multiple processes. Programs developed
  with asyncoro have same logic and structure as programs with
  threads, except for a few syntactic changes. asyncoro supports
  socket I/O notification mechanisms epoll, kqueue, /dev/poll (and
  poll and select, where necessary), and Windows I/O Completion Ports
  (IOCP) for high performance and scalability, and SSL for security.
</p>

<h4>Details</h4>
<p>

Traditional methods of threads and synchronous sockets have many
drawbacks, especially with Python due to global interpreter lock (GIL)
that forces only one active thread of execution. This approach is not
suited for large number of concurrent connections, known
as <a href="http://www.kegel.com/c10k.html">C10K problem</a>. In
addition, threads in Python have both memory and time overheads,
especially on multi-core systems
(see <a href="http://www.dabeaz.com/python/GIL.pdf">Inside the Python
GIL</a>).</p>

<p>
  Many <a href="http://nichol.as/asynchronous-servers-in-python">asynchronous
  frameworks</a> are now available to deal with this problem. Unlike
  these frameworks, asyncoro framework is very similar to the thread
  based programming so that there is almost no learning curve -
  existing thread implementations can be converted to asyncoro almost
  mechanically (although it cannot be automated). In fact, it may be
  easier to use asyncoro than threads, as locking is not required with
  asyncoro (see below). Moreover, asyncoro framework is very small
  (about 3000 lines in a single file 'asyncoro.py'), so it is easy to
  understand how it works and how to program with it. While not
  required to program with asyncoro,
  <a href="http://www.dabeaz.com/coroutines/index.html">A Curious
  Course on Coroutines and Concurrency</a> offers details on generator
  functions and coroutines.
</p>

<p>
For example, a simple tcp server with asyncoro looks like:
</p>
<code>def process(sock, coro=None):
    # convert sock to asynchronous socket
    sock = AsynCoroSocket(sock)
    # get (exactly) 4MB of data, for example, and let other coroutines
    # (process methods, in this case) execute in the meantime
    data = yield sock.recvall(4096*1024)
    # ...
    yield sock.sendall(reply)
    sock.close()

if __name__ == '__main__':
    host, port = '', 3456
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.bind((host, port))
    sock.listen(128)
    while True:
        conn, addr = sock.accept()
        Coro(process, conn)
</code>

<p>
Here we mixed synchronous sockets in server loop and asynchronous
sockets in the <em>process</em> method for illustration. The server
does not do any processing, so the loop can quickly accept
connections. Each request is processed in a separate coroutine. Note
that I/O event loop is transparent - asyncoro's scheduler handles I/O
events automatically. A coroutine should have <em>coro=None</em>
default argument. The coroutine builder Coro (which is similar to
threading.Thread) will set coro argument with the Coro instance, which
can used for calling methods in Coro class (see below). In the
<em>process</em> method, socket I/O operations are called with
<em>yield</em>. With these statements, the I/O operation is initiated
and control goes to asyncoro's scheduler for scheduling other
coroutines as well as processing I/O events. When an I/O operation is
complete, the scheduler returns the results of the I/O operation back
to the method. During the time it takes to complete an I/O operation,
the scheduler executes other coroutines (in this case,
other <em>process</em> coroutines).
</p>

<p>
  asyncoro has been tested with Python versions 2.7 and 3.2 under
  Linux, OS X and Windows. Under Windows asyncoro uses IOCP only
  if <a href="https://sourceforge.net/projects/pywin32/files/pywin32/">Python
  for Windows Extensions</a> (pywin32) is installed. pywin32 works
  with Windows 32-bit and 64-bit.
</p>

<p>
  asyncoro can be used to concurrent programs with coroutines running
  on a single instance of asyncoro, or distributed and concurrent
  programs with coroutines running on multiple instances either on a
  single node, or multpiple nodes over network.
  </p>

<h4>API for Coroutines (Concurrent Programs)</h4>

<p>See also <a href="discoro.html">API for Distributed Coroutines</a>.
  </p>

<p>
  asyncoro framework consists of AsynCoro scheduler, Coro factory to
  create coroutines from generator functions, AsynCoroSocket to
  convert regular synchronous sockets to asynchronous (non-blocking)
  sockets, AsynCoroDBCursor to convert database cursor
  operations <em>execute</em>, <em>executemany</em>
  and <em>callproc</em> to asynchronous operations, and locking,
  condition, event, semaphore primitives similar to thread
  primitives.
  </p>

<ul>
  <li>
    <b>AsynCoro</b> is a (singleton) scheduler that runs coroutines
    similar to operating system's scheduler that runs multiple
    processes. It is initialized automatically when a coroutine is
    created. If necessary, the scheduler instance can be obtained
    with <tt>AsynCoro()</tt> or <tt>AsynCoro.instance()</tt>. The
    scheduler runs in a separate thread from user program. It has
    three methods:
    <ul>
      <li>
	<b>cur_coro()</b> method returns coroutine (instance of Coro)
	being executed. As mentioned below, coroutines
	have <em>coro</em> variable (parameter to generator function,
	to be specific) that can be used more efficiently instead.
      </li>
      <li>
	<b>join()</b> method waits for all scheduled non-daemon
	coroutines to finish. After join returns, more coroutines can
	be created (which are added to scheduler).
      </li>
      <li>
	<b>terminate()</b> method terminates all scheduled
	coroutines and then the scheduler itself. If necessary, a new
	scheduler instance may be created with <tt>AsynCoro()</tt>
	or <tt>AsynCoro.instance()</tt>.
      </li>
    </ul>
    </li>
  <li>Threads in synchronous programs can be replaced with coroutines
    using asyncoro's <b>Coro</b> class (i.e., Coro replaces
    threading.Thread). <tt>Coro(target[, arg1, arg2, ...])</tt>
    creates a coroutine. <em>target</em> must be a generator function
    (a function with <em>yield</em>
    statements). <em>arg1</em>, <em>arg2</em> etc. are arguments or
    keyword arguments to <em>target</em>. <em>target</em> generator
    function must have <em>coro=None</em> keyword argument. Coro
    instantiation replaces <em>None</em> with the instance of Coro, so
    coroutine can use this to invoke methods in Coro class (see
    below). Consider the generator function (where <em>sock</em> is
    asynchronous socket and all statements are asynchronous, so all
    are used with <em>yield</em>)

    <code>def get_reply(sock, msg, coro=None):
    yield sock.sendall(msg)
    yield coro.sleep(1)
    yield sock.recv(1024)</code>
    It can be made a coroutine with
    <tt>Coro(get_reply, conn, "ping")</tt> so that generator function
    get_reply is called with <tt>sock=conn,
    msg="ping"</tt>. <em>coro</em> keyword argument is automatically
    supplied by Coro; it should not be in the arguments to Coro. When
    a coroutine is created with Coro, it is added to AsynCoro
    scheduler and starts executing - there is no need to start it
    explicitly, as done with threads. Note that generator functions
    cannot use <em>return</em> statement. With asyncoro, a <tt>raise
    StopIteration(v)</tt> effectively serves as <tt>return v</tt>. If
    a generator/coroutine does not use StopIteration, then the last
    value yielded in the generator becomes the return value. Thus, in
    the example above <em>get_reply</em> does not use StopIteration,
    so buffer received (in the last <em>yield</em>) is equivalent to
    return value of <em>get_reply</em>.
    </li>
  <li>Within a coroutine, <em>coro</em> variable refers to the
  coroutine (instance of Coro class). This variable can be used to
  invoke methods of Coro class, use it in other coroutines, for
  example, to wakeup from sleep etc. A coroutine has following
  methods:
    <ul>
      <li><b>suspend(timeout=None, alarm_value=None)</b> method should
      be used with <em>yield</em> statement. <b>sleep</b> is synonym
      for <em>suspend</em>. If timeout is a positive number (float or
      int), AsynCoro suspends execution of coroutine until that many
      seconds (or fractions of second). If timeout is None, the
      coroutine is not woken up by AsynCoro - some other coroutine
      needs to resume it. The value yielded by this method is the
      value it is resumed with or alarm_value if resumed by AsynCoro
      due to timeout.  If timeout=0, this method returns alarm_value
      without suspending the coroutine.  For example, if a coroutine
      executes <tt>v = yield coro.sleep(2.9)</tt>, it is suspended for
      2.9 seconds. If before timeout, another coroutine wakes up this
      coroutine (with
      <em>resume</em> method) with a value, <em>v</em> is set to that
      value. Otherwise, after 2.9 seconds, this coroutine is resumed
      with None (default alarm_value) so <em>v</em> is set to None and
      coroutine continues execution. During the time coroutine is
      suspended, scheduler executes other scheduled coroutines. Within
      a coroutine coro.sleep must be used (with <em>yield</em>)
      instead of time.sleep.
      </li>
      <li>
	<b>resume(update=None)</b> method should be invoked on a
	suspended coroutine. <b>wakeup</b> is synonym
	for <em>resume</em>. As explained above, the suspended
	coroutine gets <em>update</em> (any Python object) as the
	value of yield statement that caused it to
	suspend. If <em>resume</em>/<em>wakeup</em> is called on a
	coroutine that is not currently suspended/sleeping, the resume
	is ignored. If sleep/resume synchronization is needed (so that
	resume waits until specific suspend is ready to receive),
	Event locking primitive can be used so that resuming coroutine
	waits on an event variable and suspending coroutine sets the
	event before going to sleep.
	</li>
      <li><b>send(msg)</b> method sends message <em>msg</em>, which
      can be any Python object. If the coroutine is currently waiting
      for messages (with <em>receive</em>), then it is resumed
      with <em>msg</em>. If it is not currently waiting for messages,
      the message is queued so that next <em>receive</em> returns the
      message without suspending.
	</li>
      <li><b>receive(timeout=None, alarm_value=None)</b> method should
      be used with <em>yield</em>.  If there are any messages
      available (that have been sent earlier with <em>send</em>), this
      method returns earliest queued message; otherwise, the coroutine
      is suspended until <em>timeout</em>, same as in the case of
      <em>suspend</em>.  If called with timeout=0, this method will
      not suspend the coroutine; it will return either earliest
      queued message if available or alarm_value.
      <p>
	Although it is possible to use <em>send</em>/<em>receive</em>
	as producer/consumer recipe, it is not very efficient for high
	bandwidth use; see chat server in Examples section where deque
	is used along with asyncoro's Event locking primitive.
	</p>
      </li>
      <li>
	<b>set_daemon()</b> method marks the coroutine a daemon
	(process that never terminates). Similar to threading module,
	AsynCoro scheduler waits for all non-daemon coroutines to
	terminate before exiting.
	</li>
      <li>
	<b>throw(exc)</b> method throws exception exc to
	coroutine coro (at the point where it is currently executing).
	</li>
      <li>
	<b>terminate()</b> method terminates the coroutine. This
	is useful, for example, to terminate server processes that
	otherwise never terminate.
	</li>
      <li>
	<b>value()</b> method returns the last value yielded by the
	coroutine, possibly waiting until coroutine terminates. This
	method should not be called from a coroutine - this will cause
	entire coroutine framework to deadlock.  This method is meant
	for main thread in the user program to wait for (main)
	coroutine(s) it creates. If one coroutine needs to wait for
	another to finish, they can use asyncoro's locking primitive
	Event (see below) so first coroutine waits on the event
	variable (with <em>yield</em>) and finishing coroutine sets
	the variable.
	</li>
      <li>
	<b>hot_swappable(flag)</b> method marks if the coroutine's
	generator function can be replaced. This method can be used to
	set (with flag=True) or clear (with flag=False) the flag. With
	hot swapping, specific coroutines' code can be upgraded
	while the application is running.
	</li>
      <li>
	<b>hot_swap(target [, arg1, arg2, ...])</b> method requests
	AsynCoro to replace coroutine's generator function
	with <em>target(arg1, arg2, ...)</em>. AsynCoro then throws
	HotSwapException in the coroutine when a) coro indicated it
	can handle hot swap (i.e., last called hot_swappable with
	flag=True), b) it is currently executing at top-level (i.e.,
	has not called other generator functions) and c) has no
	pending asynchronous operations (socket I/O, tasks scheduled
	with AsyncThreadPool, and database cursor tasks). The new
	generator is set as args[0] of HotSwapException, so the coro
	can inspect new generator, if necessary, and can do any
	preparation for hot swapping, e.g., saving state (perhaps by
	sending state as a message to itself which can be retrieved in
	the new generator with <em>receive</em>), or even ignore
	hot swap request. If/when it is ready for swap, it
	must re-raise the same HotSwapException (with the new
	generator as args[0]). This causes AsynCoro to close current
	generator, replace it with the new generator and schedule new
	generator for execution (from the beginning). Any messages
	(i.e., resume updates) queued in the previous generator are
	not reset, so new generator can process queued messages (e.g.,
	use <em>receive</em> in a loop with timeout=0
	until <em>receive</em> returns alarm_value). Note that
	<em>hot_swap</em> changes generator function of a particular
	coroutine for which it is called. If there are many coroutines
	using that generator function, <em>hot_swap</em> may be called
	for each such coroutine.
	</li>
      <li>
	<b>monitor(coro)</b> method should be used
	with <em>yield</em>. It sets the caller as the monitor of
	coroutine <em>coro</em>. Then, when the coroutine is finished,
	either because coroutine's generator function finished
	exceution (i.e., raised StopIteration exception) or was
	terminated by AsynCoro because of an uncaught exception,
	AsynCoro throws MonitorException in coroutine's
	monitor. MonitorException's args[0] is set to the affected
	coroutine and args[1] is set to the exception tuple: If
	coroutine finished execution, the tuple is a pair, with first
	element set to (type) StopIteration and second element
	instance of StopIteration with the last value yielded by
	coroutine, and if coroutine was terminated due to uncaught
	exception, the tuple will have either 2 or 3 elements, with
	first element set to the type of exception, second element set
	to the uncaught exception, and third element set to trace, if
	available. The monitor can inspect MonitorException and
	possibly restart the affected coroutine (see below). A
	coroutine can be monitored by at most one monitor, and a
	monitor can monitor any number of coroutines. Monitors can
	also be chained, so if a monitor itself finishes (e.g., fails
	to process MonitorException), then the exception is thrown in
	its monitor, if it has one, etc.
	</li>
      <li>
	<b>restart(target[, arg1, arg2, ...])</b> method requests
	AsynCoro to restart the coroutine with generator
	function <em>target(arg1, arg2, ...)</em>. A monitoring
	coroutine, for example, can restart a finished or terminated
	coroutine, possibly with a different generator and
	arguments. AsynCoro keeps any pending messages from previous
	generator, so new generator function can process those
	messages.
	</li>
    </ul>
    Methods <em>register</em> and <em>reference</em> are useful only
    when asyncoro is used for distributed programming;
    see <a href="discoro.html">API for Distributed Coroutines</a> for
    details.

    <p>With <em>monitor</em>, <em>restart</em> and <em>hot_swap</em>,
      fault-tolerant coroutines and applications can be developed.</p>
  </li>
  <li>
    A synchronous (regular) socket <em>sock</em> can be converted to
    asynchronous (non-blocking) socket
    with <b>AsynCoroSocket</b>(sock). SSL can be enabled
    with <b>AsynCoroSocket</b>(sock, keyfile=key, certfile=cert,
    ssl_version=version), where <em>keyfile</em>, <em>certfile</em>
    and <em>ssl_version</em> are as per <em>wrap_socket</em> method
    in <a href="http://docs.python.org/library/ssl.html">ssl
    module</a>. Socket operations <em>accept</em>, <em>connect</em>,
    <em>send</em>, <em>recv</em>, <em>sendall</em>, <em>recvall</em>,
    <em>send_msg</em>, <em>recv_msg</em>, <em>sendto</em>
    and <em>recvfrom</em> for asynchronous sockets must be used with
    'yield' statement. The value of such yield statement is the result
    of the socket I/O operation (for example, for <em>recv</em>, it
    would be the buffer received by the socket). The socket returned
    from <em>accept</em> method of an asynchronous socket is also an
    asynchronous socket, so there is no need to convert it. The
    methods <em>recvall</em>, <em>send_msg</em> and <em>recv_msg</em>
    are available for AsynCoroSocket only - they are not standard
    socket methods: <em>recvall</em> receives exactly given number of
    bytes (counterpart to <em>sendall</em>), <em>send_msg</em>
    prefixes the given buffer with the length so that receiving side
    knows exactly how many bytes to receive, and <em>recv_msg</em>
    receives full message from <em>send_msg</em>.
    </li>
  <li>
    asyncoro
    provides <b>Lock</b>, <b>RLock</b>, <b>Condition</b>, <b>Event</b>
    and <b>Semaphore</b> primitives. They are similar to versions in
    threading module. Any operation that would block in threading
    module is implemented as asynchronous operation in asyncoro. Such
    operations must be called with <em>yield</em> appropriately. For
    example, acquiring a lock may block, so it should be invoked as
    <tt>yield lock.acquire()</tt>. Similarly, Event's wait method or
    Condition's wait method must be used as
    <tt>yield event.wait()</tt> or <tt>yield
    condition.wait()</tt>. For example, Condition variable cv in a
    client should be used as (compare to example at
    <a href="http://docs.python.org/library/threading.html#condition-objects">threading
    module</a>)

    <code>while True:
      yield cv.acquire()
      while not an_item_is_available():
          yield cv.wait()
      get_an_available_item()
      yield cv.release()</code>

    <em>yield</em> is not needed when releasing a lock. However, to be
    cooperative with other coroutines that might be waiting for their
    turn to execute (e.g., waiting to acquire same Condition
    variable), it may be used where appropriate - each <em>yield</em>
    transfers control to asyncoro's scheduler, which may schedule a
    different coroutine that is ready to execute. See documentation
    strings in 'asyncoro.py' for more details on which methods should
    be used with <em>yield</em> and which methods need not be. <br/>
    Technically, locking may not be needed in most cases (where
    'yield' is not used in critical sections), as there is no forced
    preemption with coroutines and at most one coroutine is executing
    at anytime; in fact, the implementation of these primitives in
    asyncoro updates lists and counters without locking.
    </li>
  <li>
    Within a coroutine, generator functions must be called with
    <em>yield</em> statement: If <em>g</em> is a generator function,
    it should be called as <tt>v = yield g()</tt>. Regular
    functions/methods can be called without <em>yield</em>.
    </li>

  <li><b>AsyncChannel</b> is a (virtual) channel through which
    coroutines can exchange messages. Messages sent to AsyncChannel
    are delivered to current subscribers (recipients). An AsyncChannel
    can be created with <em>AsyncChannel(name, transform=None,
    min_receivers=0)</em> where
    <ul>
      <li><em>name</em> is name of channel (which must be unique)</li>
      <li><em>transform</em>, if given, must a function that is called
	before a message is delivered to subscribers. The function is
	called with name of the channel and the message. It should
	return transformed message or <em>None</em>. If <em>None</em>
	is returned, the message is dropped - subscribers will not
	receive the message. Otherwise, transformed message is sent to
	subscribers.</li>
      <li><em>min_receivers</em> is minimum number of recipients that
	each message must be delivered to (see below).</li>
    </ul>
    A channel has following methods.
    <ul>
      <li>A coroutine (or even another channel) can subscribe to a
	channel with <b>subsribe(subscriber)</b>. Any messages sent to
	the channel are then sent to each subscriber; i.e., messages
	are broadcast to all subscribers. It is possible to chain or
	create hierarchical channels with channels subscribing to
	other channels.
      </li>
      <li><b>send(message)</b> calls <em>transform</em> function of
	the channel (see above) if it has one. If the function
	returns <em>None</em>, the message is ignored. Otherwise an
	instance of _ChannelMessage, created with the name of the
	channel and (transformed) message, is sent to current
	subscribers. A coroutine <em>coro</em>, for example, that has
	subscribed to the channel can receive messages with <em>msg =
	coro.receive()</em>. <em>msg</em> has two
	attributes: <em>channel</em> which is the name of the channel
	and <em>message</em> which is the original message sent to the
	channel. Note that a coroutine can also send messages to other
	coroutines. Such messages are not instances of
	_ChannelMessage, so if there is a chance that a recipient can
	receive messages sent by either channels or coroutines, it may
	check message type, for example, with <em>isinstance</em>, and
	process accordingly.
      </li>
      <li><b>deliver(message)</b> is similar to <em>send</em>, except
	that it blocks until at least <em>min_receivers</em> are
	subscribed. Thus, deliver guarantees that a message is sent to
	at least <em>min_receivers</em>. This method must be called
	with <em>yield</em>.
      </li>
      <li><b>unsubscribe(subscriber)</b> unsubscribes the subscriber
	(coroutine or another channel), so future messages to the
	channel are not sent to that subscriber.
      </li>
    </ul>
    Methods <em>register</em> and <em>reference</em> are useful only
    when asyncoro is used for distributed programming;
    see <a href="discoro.html">API for Distributed Coroutines</a> for
    details.
  </li>

  <li><b>SyncChannel</b> is similar to <em>AsyncChannel</em>, except
    that whereas messages to AsyncChannel are sent to current
    subscribers, messages to SyncChannel are sent to coroutines
    currently waiting to receive from that channel. Thus, to recieve
    messages, a coroutine must use <em>msg = channel.receive(coro,
    timeout=None, alarm_value=None)</em>, where <em>coro</em> is the
    coroutine that will block until a message is sent to the
    channel, <em>timeout</em> is number (or fractions) of seconds to
    block and <em>alarm_value</em> is the value received in case of
    timeout. The message received by coroutine is an instance of
    _ChannelMessage. Note that other channels cannot receive messages
    sent to a SyncChannel.
    </li>

  <li>
    <b>AsynCoroThreadPool</b> can be used to schedule synchronous,
    time consuming operations with a pool of threads for asynchronous
    completions (similar to sockets). A new thread pool can be created
    with <tt>AsynCoroThreadPool(num_threads)</tt>.  It provides three
    methods:
    <ul>
      <li><b>async_task</b>(coro, target, *args, **kwargs) schedules
	given task, Python function <em>target</em> with
	arguments <em>args</em> and keyword arguments <em>kwargs</em>,
	with the thread pool. This method suspends the calling
	coroutine <em>coro</em>, so it must be used with <em>yield</em>. The
	task is executed in one of the threads in the pool. Once the
	task is complete, <em>coro</em> is resumed with the return
	value from <em>target</em>. Thus, in a
	coroutine <em>coro</em>, the statement
	<tt>v = yield thread_pool.async_task(coro, f, 1)</tt> executes
	function <em>f(1)</em> in a thread and its return value is set
	to <em>v</em>.
      </li>
      <li><b>join()</b> method waits for all scheduled tasks to be
	completed. More tasks can be added if necessary.
      </li>
      <li><b>terminate()</b> method waits for all scheduled tasks to be
	completed and terminates the threads. Tasks added later will
	not be executed.
      </li>
    </ul>
    As coroutines run in a separate thread, any variables shared
    between coroutines and tasks scheduled with thread pool must be
    protected by thread locking (not coroutine locking). As I/O event
    loop is part of AsynCoro scheduler, holding thread locks prevents
    the scheduler from reacting to I/O events quickly, so it is
    expected that if thread locks are used, they are used for very
    brief periods.
    </li>
  <li>
      Database operations are blocking operations and do not provide
      asynchronous notification. asyncoro
      provides <b>AsynCoroDBCursor</b> that
      schedules <em>execute</em>, <em>executemany</em>
      and <em>callproc</em> operations through AsynCoroThreadPool for
      asynchronous completion. Other database operations are
      considered very fast. This interface works with MySQLdb under
      Python version 2.x
      and <a href="https://github.com/petehunt/PyMySQL">pymysql</a>
      under Python version 3.x. If necessary other database interfaces
      and operations can be made asynchronous with AsynCoroThreadPool.
    <p>
      As database connections and cursors are not supposed to be
      shared among threads, AsynCoroDBCursor executes operations on a
      cursor sequentially. Operations on different cursors at the same
      time are run concurrently. A simple example is

      <code># create pool of threads
num_threads = 3
thread_pool = asyncoro.AsynCoroThreadPool(num_threads)
async_cursors = []
for x in range(num_threads):
    conn = MySQLdb.connect(host=host, user=user, passwd=passwd, db=db)
    cursor = conn.cursor(cursorclass=MySQLdb.cursors.DictCursor)
    # convert cursor to asynchronous cursor using thread_pool to
    # schedule operations
    async_cursors.append(asyncoro.AsynCoroDBCursor(thread_pool, cursor))

# 3 cursors are used in 10 coroutines
for _, async_cursor in itertools.izip(range(10), itertools.cycle(async_cursors)):
    asyncoro.Coro(db_proc, async_cursor)

def db_proc(cursor, coro=None):
    # ...
    n = yield cursor.execute(stmt)
    rows = cursor.fetchall()
    # process rows</code>
      </p>
    </li>
  </ul>

<h4>Examples</h4>
<a href="examples.html">Examples</a> illustrate how to use asyncoro.

	  </div>
	</div> 
      </div> 
    </div> 
    <div id="footer"> 
      <p> 
        <a href="http://sourceforge.net/"> 
          Project Web Hosted by <img src="http://sflogo.sourceforge.net/sflogo.php?group_id=539226&amp;type=3" alt="SourceForge.net" /> 
        </a> 
      </p> 
      <p> 
        &copy;Copyright 1999-2009 -
        <a href="http://geek.net" title="Network which provides and promotes Open Source software downloads, development, discussion and news."> 
          Geeknet</a>, Inc., All Rights Reserved
      </p> 
      <p> 
        <a href="http://sourceforge.net/about"> 
          About
        </a> 
        -
        <a href="http://sourceforge.net/tos/tos.php"> 
          Legal
        </a> 
        -
        <a href="http://p.sf.net/sourceforge/getsupport"> 
          Help
        </a> 
      </p> 
    </div> 
  </body> 
</html> 
